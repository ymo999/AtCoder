'''
参考
https://note.com/sdestiny/n/nbd01567e6f7a
テレポート回数=Kは制約で
1<=K<=10**18
とされているため、愚直にシミュレーションしていると実行時間制限を超過してしまう
ただし、町の数=Nは
2<=N<=2*10**5
となっており実行時間制限に影響はないと思われる
---
テレポータが示す転送先=dstと、各町の訪問回数を参照しながら、
・訪問した町=Aのインデックスの記録=visit
・各町の訪問回数をカウントアップ（0→1）=cnt
をすると、どこかで必ず2回目に訪問する町が出現する⇒ループ発生
---
ループ発生したら記録先を切り替え、
・ループ発生以降に訪問した町=Aのインデックスの記録=loop
・各町の訪問回数をカウントアップ（1→2）=cnt
を同様に行う
---
カウントが「2」となっている町が次の訪問箇所となったら、記録とカウントを中止する（ループ終端）
---
1.Kから、ループ終端前までの回数=len(visit)+len(loop)を減算
2.上記「1.」の数値を、ループしている町の数=len(loop)で割った余り=ans
が示すインデックスに該当する、ループ発生以降に訪問する町=loop[ans]+1が解となる
（Kは考慮せずとも、ループはどこかで必ず発生するため記録処理が無限ループになることはない）
※ループ発生前にテレポートが終了する場合：len(visit)>Kは、そのままvisit[K]+1が解となる
'''

N, K = map(int, input().split())
A = list(map(int, input().split()))

dst= 0          # テレポータが示す訪問先（インデックスにするため-1する）
visit = []      # ループ発生前に訪問した町のインデックスを記録
loop = []       # ループ発生以降に訪問した町のインデックスを記録
cnt = [0] * N   # 各町の訪問回数

while cnt[dst] < 2:         # 訪問先が3回目となったら終了
    if cnt[dst] == 0:       # 未訪問（1回目の訪問）
        visit.append(dst)
    else:                   # 1度訪問済（2回目の訪問=ループ発生以降）
        loop.append(dst)
    cnt[dst] += 1
    dst = A[dst] - 1        # その町にあるテレポータが指定する訪問先（インデックスなので-1する）

if len(visit) > K:
    print(visit[K]+1)
else:
    tmp = K - len(visit) - len(loop)
    ans = tmp % len(loop)
    print(loop[ans]+1)
